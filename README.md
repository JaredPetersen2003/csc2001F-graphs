# CSC2001F 2023 Assignment 5

## Instructions

The goal of this assignment is to programmatically compare the performance of Dijkstra's shortest paths algorithm (as per the course slides) with the theoretical performance bounds.

## Dataset Generation and Basic Operation

Write an application to generate data, insert the data into a graph and measure the performance experimentally.  Use the attached code (from the textbook) as a starting point (or write everything from scratch or use standard code from elsewhere).

For a single test, you need to assume values for |V| (number of vertices) and |E| (number of edges), then generate a random dataset (in the same format as Graph1.txt).  Save the dataset to a file on disk (so the experiment can be validated later).  Then, load the data into a graph and run Dijkstra's algorithm to determine shortest paths.

For multiple tests, you will need to repeat these operations for different values of |V| and |E|,   You can assume the first vertex in each dataset is the source; or you can loop over all source vertices and take averages.

You should be able to invoke your application using "make run" or a command such as

`java -cp bin GraphExperiment`

Your program should take in no command-line parameters and use no interactive user input.

## Instrumentation

Add additional code to the program to discretely count the number of times you do vertex-processing and edge-processing operations in the code.  This is called instrumentation.  There are 3 basic steps.

First, create a variable/object (e.g., vCount=0) somewhere in the code to track the counter; maybe use an instance variable in the data structure class.  Initialise it to 0 whenever a new set of measurements is about to be taken.

Secondly, wherever there is an operation you want to count, increment the counter (vCount++).  For example:

some loop over vertices: 

`vCount++;   // instrumentation`
...

Store all of these data points in an internal data structure where you can keep track of (V, E, vCount, eCount).

Finally, report the values to the screen or a file before the program terminates.

## Experiment Parameters

Vary the size of V and E and measure the number of vertex-processing and edge-processing operations for different values of V and E.  Use at least 5 different values of V, such as {10, 20, 30, 40, 50}.  Then, for each value of V, use different values of E.  Since |E|<|V|2, for V=10, the E values must range between 0 and 100.  Since a very sparse graph is not realistic, maybe use E={20,35,50,65,80} as evenly-spaced increments that avoid sparse graphs and also avoid fully-connected graphs.

For vertex names, maybe use "NodeXXX" where the XXX is an integer.  When generating edges randomly, you must not generate edges that already exist and you must not generate edges where the source and destination are the same.  Maybe use an integer in the range 1-10 for edge costs.

For each pair of values of V and E, your program will then generate a dataset and measure performance.

## Report

Write a report (of up to 8 pages) that includes the following:

    What your OO design is: what classes you created and how they interact (1 page at most).
    What the goal of the experiment is and how you executed the experiment.  Report on any experiment design decisions you made.
    What your final results are (use one or more (mathematical) graphs), showing how the algorithm performs for different types/sizes of (data structure) graphs (different E and V values). 
    Discuss what the results mean.  Compare your results to the theoretical bounds.
    A statement of what you included in your submission that constitutes creativity - how you went beyond the basic requirements of the assignment.
    Summary statistics from your use of git to demonstrate usage.  Print out the first 10 lines and last 10 lines from "git log" , with line numbers added.  You can use a Unix command such as:

git log | (ln=0; while read l; do echo $ln\: $l; ln=$((ln+1)); done) | (head -10; echo ...; tail -10)

## Dev requirements

As a software developer, you are required to make appropriate use of the following tools:

    git, for source code management
    javadoc, for documentation generation
    make, for automation of compilation and documentation generation

## Submission requirements

Submit a .tar.gz compressed archive containing:

    Makefile
    src/
        all source code
    bin/
        all class files
    doc/
        javadoc output
    data/
        data files generated by your program
    report.pdf

Your report must be in PDF format.  Do not submit the git repository.
Marking Guidelines

Your assignment will be marked by tutors, using the following marking guide.
Artefact 	Aspect 	                                                            Mark
Report 	    Appropriate design and implementation of OOP and data structures 	10
            Experiment description 	                                            10
        
            Results - tables and/or graphs 	                                    10
            Discussion of results 	                                            10
            Creativity 	                                                        10
            Git usage log 	                                                     5
Code 	Works correctly, looks reasonable and no obvious inefficiencies 	    20
Data 	Dataset files look correct 	                                            10
Dev 	Documentation - javadoc 	                                            10
  	Makefile - make and clean targets (docs is optional) 	                     5